<!DOCTYPE html>
<html lang="en">
  <head>
    <meta content="text/html; charset=iso-8859-15" http-equiv="content-type">
    <title>Addendum to in the Broadcom VideoCore IV documentation</title>
    <meta content="Marcel M&uuml;ller" name="author">
    <meta content="vc4asm instruction set" name="keywords">
    <link rel="stylesheet" href="infstyle.css" type="text/css">
  </head>
  <body>
    <h1>Addendum to the <a href="http://www.broadcom.com/docs/support/videocore/VideoCoreIV-AG100-R.pdf">Broadcom
        VideoCore IV documentation</a></h1>
    <h2>Additional features and erratas</h2>
    <h3>Section 3: Writing to <tt>r5</tt></h3>
    <p><tt>r5</tt> can be written <em>from the elements 0, 4, 8 and 12</em> for
      each slice <em>or only from element 0</em>, depending on whether you
      write to regfile A or regfile B. vc4asm supports the register names <tt>r5quad</tt>
      and <tt>r5rep</tt> for this purpose. The documentation is wrong, nothing
      is concatenated from low order bytes.</p>
    <h3>Horizontal vector rotation</h3>
    <p>Both source operands must be from accumulator <tt>r0</tt>..<tt>r3</tt> <em>or
        <tt>r5</tt></em> but not <tt>r4</tt> for full vector rotation. But if
      you choose not to do so the rotation will only take place within the
      slices. I.e. [0,1,2,3, 4,5,6,7, 8,9,10,11, 12,13,14,15] rotates to
      [3,0,1,2, 7,4,5,6, 11,8,9,10, 15,12,13,14]. In fact all source operands
      are taken from the current element and only the write is rotated within
      the slice by the lower two bits. This can be particularly useful in some
      cases.</p>
    <p>Furthermore the restriction that the source register of the vector
      rotation must not be written in the previous instruction applies <em>if
        the values are transferred to a lower QPU slice</em> only. You may
      prevent this by an appropriate <code>.if<var>cc</var></code> extension.</p>
    <h3>Section 3: Small immediate values</h3>
    <p>The small immediate codes for vector rotations can also be used as
      additional constants. Well, all of them are redundant with [16..31] but
      this allows you to combine vector rotations with immediate values. vc4asm
      will take care of this.</p>
    <table border="1" cellpadding="3" cellspacing="0">
      <thead>
        <tr>
          <th>value</th>
          <th>encoding</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>0x30 = 48</td>
          <td>0xfffffff0 = -16</td>
        </tr>
        <tr>
          <td>0x31 = 49</td>
          <td>0xfffffff1 = -15</td>
        </tr>
        <tr>
          <td>0x32 = 50</td>
          <td>0xfffffff2 = -14</td>
        </tr>
        <tr>
          <td>0x33 = 51</td>
          <td>0xfffffff3 = -13</td>
        </tr>
        <tr>
          <td>0x34 = 52</td>
          <td>0xfffffff4 = -12</td>
        </tr>
        <tr>
          <td>0x35 = 53</td>
          <td>0xfffffff5 = -11</td>
        </tr>
        <tr>
          <td>0x36 = 54</td>
          <td>0xfffffff6 = -10</td>
        </tr>
        <tr>
          <td>0x37 = 55</td>
          <td>0xfffffff7 = -9</td>
        </tr>
        <tr>
          <td>0x38 = 56</td>
          <td>0xfffffff8 = -8</td>
        </tr>
        <tr>
          <td>0x39 = 57</td>
          <td>0xfffffff9 = -7</td>
        </tr>
        <tr>
          <td>0x3a = 58</td>
          <td>0xfffffffa = -6</td>
        </tr>
        <tr>
          <td>0x3b = 59</td>
          <td>0xfffffffb = -5</td>
        </tr>
        <tr>
          <td>0x3c = 60</td>
          <td>0xfffffffc = -4</td>
        </tr>
        <tr>
          <td>0x3d = 61</td>
          <td>0xfffffffd = -3</td>
        </tr>
        <tr>
          <td>0x3e = 62</td>
          <td>0xfffffffe = -2</td>
        </tr>
        <tr>
          <td>0x3f = 63</td>
          <td>0xffffffff = -1</td>
        </tr>
      </tbody>
    </table>
    <h3>Section 7: QPU Reading and Writing of VPM</h3>
    <p>VPM reads seem to <em>block immediately if the FIFO is empty</em>. No
      undefined data is returned when the reads are made too early.</p>
    <p>Furthermore the <em>VPM read setups cannot be queued</em>. Only if the
      result of the last VPM read setup is fully transferred to the VPM FIFO,
      i.e. there is no more than one value outstanding, a new setup is accepted.<br>
      Example: if you request 2 reads with the first write to <tt>vr_setup</tt>
      and another two reads with the second write, then the second job is
      ignored and you can read only two values without a deadlock. In contrast,
      if you request 1 read by the first setup and 3 by the second one, then
      everything is fine, since the single read of the first setup is
      immediately transferred to the FIFO and the setup is discarded. No delay
      slot instructions are required in the latter case.</p>
    <h3>Table 35: VCD DMA Write (VDW) Stride Setup Format</h3>
    <p>Unlike the documentation suggests the <tt>STRIDE</tt> field is <em>16
        bits wide</em>. Probably just a typo.</p>
    <h2>Instruction constraints</h2>
    <h3>No conditional write to peripheral registers</h3>
    <p>A write to the TMU retiring register (TMU0_S, TMU1_S) or VPM must not use
      conditional write access. Although the conditional write itself works the
      TMU/VPM fifo is triggered unconditional to process the request with
      undefined data in case the condition is not true. Probably any other
      peripheral register share the same problem.</p>
    <p>vc4asm warns about this kind of access in verify mode.</p>
    <h3>Distance of branch instructions</h3>
    <p>There must be at least two non branch instructions between every two
      branch instructions. Otherwise no branch is taken or the thread will
      crash. This also applies if the branch conditions are reverse and only one
      of the branches can actually be taken.</p>
    <p>However, you can enqueue the next branch just before the last one is
      taken. Example:</p>
    <pre># r0 contains semaphore number [0..15]<br>mul24 ra31, r0, 3*8<br>nop<br>brr ra31, ra31, r:sacq<br>nop<br>nop<br>bra -, ra31<br>...<br><br>:sacq<br>.rep i, 16<br>nop<br>nop<br>sacq -, i<br>.endr</pre>
    <p>The above code fragment dynamically acquires a semaphore depending on the
      number in the r0 register. This is the shortest possible code fragment to
      do this task.</p>
    <h3>MUL ALU pack modes and I/O register targets</h3>
    <p>The MUL ALU pack modes that write only a single byte are not available
      for I/O register targets, i.e. <tt>waddr_mul</tt> &ge; 32. The write only
      hardware registers cannot write slices of a word.</p>
  </body>
</html>
