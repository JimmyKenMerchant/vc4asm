<!DOCTYPE html>
<html lang="en">
  <head>
    <meta content="text/html; charset=iso-8859-15" http-equiv="content-type">
    <title>VC4ASM Assembler directives</title>
    <meta content="Marcel M&uuml;ller" name="author">
    <meta content="vc4asm instruction set" name="keywords">
    <link rel="stylesheet" href="infstyle.css" type="text/css">
  </head>
  <body>
    <h1>VC4ASM - Assembler directives</h1>
    <p><a href="index.html">&uarr; Top</a>, <tt><a href="#.assert">.assert</a>
        <a href="#.back">.back</a> <a href="#.const">.const</a> <a href="#.constlc">.constlc</a>
        <a href="#.else">.else</a> <a href="#.elseif">.elseif</a> <a href="#.endb">.endb</a>
        <a href="#.endif">.endif</a> <a href="#.endm">.endm</a> <a href="#.endr">.endr</a>
        <a href="#.equ">.equ</a> <a href="#.func">.func</a> <a href="#.if">.if</a>
        <a href="#.include">.include</a> <a href="#.macro">.macro</a> <a href="#.rep">.rep</a>
        <a href="#.set">.set</a> <a href="#.setlc">.setlc</a> <a href="#.unset">.unset</a>
        <a href="#.unsetlc">.unsetlc</a></tt></p>
    <h2><a id=".const" name=".const"></a><a id=".set" name=".set"></a><tt>.const
        .set .lconst .lset</tt> - define a constant or single line function</h2>
    <pre>.const <i>identifier</i>, <i>expression</i>
.set <i>identifier</i>, <i>expression</i>
.lconst <i>identifier</i>, <i>expression</i>
.lset <i>identifier</i>, <i>expression</i>.const <var>identifier</var>(<var>argument1, argument2</var> ...) <var>expression</var>
.set <var>identifier</var>(<var>argument1, argument2</var> ...) <var>expression</var>
.lconst <var>identifier</var>(<var>argument1, argument2</var> ...) <var>expression</var>
.lset <var>identifier</var>(<var>argument1, argument2</var> ...) <var>expression</var></pre>
    <dl>
      <dt><var><tt>identifier</tt></var></dt>
      <dd>This identifier is assigned, i.e. from this line on. In case of <tt>.lset</tt>
        and <tt>.lconst</tt> the assignment is only preserved in the current
        context, e.g. the current include or macro.</dd>
      <dt><tt><var>argument1, argument2</var> ...</tt></dt>
      <dd><var></var>Function arguments. Function arguments must be expressions
        of any type including registers, but they cannot be incomplete
        expressions like operators or identifier fragments.<br>
        These are identifiers that can be used in the <var><tt>expression</tt></var>
        body like constants wherever an expression is allowed.</dd>
      <dt><tt><var>expression</var></tt></dt>
      <dd>This expression is assigned to <var><tt>identifier</tt></var>. The
        expression can be of any type including registers but it must evaluate
        at the time <tt>.set</tt> is parsed unless you have an argument list
        which causes delayed evaluation. You cannot assign incomplete
        expressions like bare operators.</dd>
    </dl>
    <p>Constants can be used wherever an expression is allowed.</p>
    <p>The assignment of <tt>.const</tt> and <tt>.lconst</tt> is final, i.e. a
      second assignment to the same identifier is an error. But final
      assignments neither prevent from shadowing in nested contexts nor from <tt>.unset</tt>.<br>
      <tt>.equ</tt> may be used as synonym for <tt>.set</tt>.</p>
    <p>Further aliases for <tt>.set</tt> are: <tt>.define</tt>, <tt>.equ</tt>.</p>
    <h3> Example</h3>
    <pre>.const ra_link_0, ra0<br><br>.set vpm_setup(num, stride, dma) (num &amp; 0xf) &lt;&lt; 20 | (stride &amp; 0x3f) &lt;&lt; 12 | (dma &amp; 0xfff)
.set v32(y, x) 0x200 | (y &amp; 0x30) | (x &amp; 0xf)<br><br>mov vw_setup, vpm_setup(1, 1, v32(0,0))
<var></var></pre>
    <h2><a name=".unset"></a><tt>.unset .lunset</tt> - revoke a constant
      definition</h2>
    <pre>.unset <i>identifier</i>.lunset <i>identifier</i></pre>
    <dl>
      <dt><var><tt>identifier</tt></var></dt>
      <dd>The assignment of this identifier is undone. This normally reverts the
        identifier to undefined state. However, if a local version of the
        identifier currently shadows another value of the same identifier the
        previous state before the shadowing is restored.</dd>
    </dl>
    <p><tt>.lunset</tt> only removes the identifier from the current local
      context.</p>
    <h2><a name=".func"></a><a name=".endf"></a><tt>.func</tt> - define a multi
      line user function</h2>
    <pre>.func <var>identifier</var>(<var>argument1, argument2</var> ...)<br> &nbsp;<var>body</var><br>.endf<var></var></pre>
    <dl>
      <dt><var><tt>identifier</tt></var></dt>
      <dd>Name of the function.</dd>
      <dt><tt><var>argument1, argument2</var> ...</tt></dt>
      <dd><var></var>Function arguments. These are identifiers that can be used
        in the function body like constants wherever an expression is allowed.</dd>
      <dt><var><tt>body</tt></var></dt>
      <dd>The function body may only contain a single expression like <a href="#.set"><tt>.set()</tt></a>.
        But you may use <tt><a href="#.if">.if</a></tt>, <tt><a href="#.assert">.assert</a></tt>
        and also <tt>.set</tt> etc. to decide what expression should evaluate.</dd>
    </dl>
    <p>Functions are similar to constants with parameters but their body is
      multi line.</p>
    <h3>Example</h3>
    <pre>.func vpm_setup(num, stride, dma)<br>  .assert num &lt;= 16 &amp;&amp; num &gt; 0<br>  .assert stride &lt;= 64 &amp;&amp; stride &gt; 0<br>  .assert (dma &amp; ~0xfff) == 0<br>  (num &amp; 0xf) &lt;&lt; 20 | (stride &amp; 0x3f) &lt;&lt; 12 | dma<br>.endf<br>.func v32(y, x)<br>  .assert (y &amp; ~0x30) == 0<br>  .assert (x &amp; ~0xf) == 0<br> &nbsp;0x200 | y | x<br>.endf<br><br>mov vw_setup, vpm_setup(1, 1, v32(0,0))</pre>
    <p>The example above provides a checked version of the example to <a href="#.set"><tt>.set</tt></a>.</p>
    <h2><a id=".macro" name=".macro"></a><a id=".endm" name=".endm"></a><tt>.macro</tt>
      - define a macro</h2>
    <pre>.macro <var>identifier, argument1, argument2</var> ...<br>    <var>your code</var><br>    ...<br>.endm</pre>
    <dl>
      <dt><var><tt>identifier</tt></var></dt>
      <dd>Name of the macro.</dd>
      <dt><tt><var>argument1, argument2</var> ...</tt></dt>
      <dd>Macro arguments. These are identifiers that can be used in the macro
        body like constants wherever an expression is allowed.</dd>
    </dl>
    <p>A macro insert a block of code at the point where it is invoked in the
      code. The code might depend on arguments. In contrast to function macros
      may emit code. But they also might contain other directives.</p>
    <p>The macro arguments must be expressions of any type including registers,
      but they cannot be incomplete expressions like operators or unresolved
      identifiers. The arguments are evaluated at the time of macro invocation
      rather than the time where they are used in the macro body. So they cannot
      depend on code in the macro body.</p>
    <h3>Example</h3>
    <p>Header of a subroutine. The entry point address is assigned to a
      register,</p>
    <pre>.macro proc, rx_ptr, label
    brr rx_ptr, label
    nop
    nop
    nop
.endm<br><br>proc ra23, r:1f<br>    <var>subroutine body</var><br>    ...<br>:1</pre>
    <h2><a id=".rrep" name="constant"></a><a id=".endr" name=".endr"></a><tt>.rep</tt>
      - repeat a code block multiple times</h2>
    <pre>.rep <var>identifier</var>, <var>count<br>    your_code</var><br>    ...<br>.endr<var></var></pre>
    <dl>
      <dt><var><tt>identifier</tt></var></dt>
      <dd>This identifier receives the loop count starting at <tt>0</tt> and up
        to <tt><var>count</var>-1</tt> for the last loop cycle.<br>
        At the end of <tt>.endr</tt> the identifier returns to undefined state.</dd>
      <dt><tt><var>count</var></tt></dt>
      <dd>Number of loop cycles. <tt><var>count</var></tt> must be <tt>&ge; 0</tt>
        and evaluate at the time <tt>.rep</tt> is parsed.</dd>
    </dl>
    <h3> Example</h3>
    <p>Acquire all 15 QPU semaphores.</p>
    <pre>.rep i 15<br>    sacq i<br>.endr</pre>
    <h2><a id=".back" name=".back"></a><a id=".endb" name=".endb"></a><tt>.back</tt>
      - emit code before the last few instructions</h2>
    <pre>.back <var>count<br>    your_code</var><br>    ...<br>.endb<var></var></pre>
    <dl>
      <dt><tt><var>count</var></tt></dt>
      <dd>Number of instructions to go back. Must be less or equal to 3.</dd>
    </dl>
    <p>The code between <tt>.back</tt> and <tt>.endb</tt> is inserted before
      the last <var><tt>count</tt></var> instructions rather than at the
      current location. This can be quite useful when dealing with macros and
      branch instruction. But be aware that there might be dependencies, e.g.
      the inserted code might modify registers that are used by last
      instructions. <tt>vc4asm</tt> will not check for that.</p>
    <h3> Example</h3>
    <pre>some_macro<br>.back 3<br>brr -, r:loop<br>.endb</pre>
    <p>The code above will insert the branch instruction before the last three
      instructions emitted by the macro <tt>some_macro</tt> or even code
      before.</p>
    <h2><a name=".if"></a><a name=".else"></a><a name=".elseif"></a><a name=".endif"></a><tt>.if</tt>
      - conditional compile</h2>
    <pre>.if <var>condition<br>    your code</var><br><var>    </var>...<br>.elseif <var>condition<br>    another code</var><br><var>    </var>...<br>.else<br>    <var>alternate code</var><br><var>    </var>...<br>.endif    </pre>
    <dl>
      <dt><tt><var>condition</var></tt></dt>
      <dd>Expression to check. The expression must be constant and of type
        integer or float and is checked to be non-zero.</dd>
    </dl>
    <h2><a id=".assert" name=".assert"></a><tt>.assert</tt> - check for static
      condition</h2>
    <pre>.assert <var>condition</var></pre>
    <dl>
      <dt><tt><var>condition</var></tt></dt>
      <dd>Expression to check. The expression must be constant and of type
        integer or float and is checked to be non-zero.</dd>
    </dl>
    <h2><a id=".include" name=".include"></a><tt>.include</tt> - include another
      file</h2>
    <pre>.include "<var>filename</var>"</pre>
    <dl>
      <dt><tt><var>filename</var></tt></dt>
      <dd>Name of another assembler file to include. The path may be relative or
        absolute.</dd>
    </dl>
    <p>An included file denotes a local context. Definitions that are local like
      <tt>.setlc</tt> are only valid within the included file and sub includes.</p>
    <pre><var></var></pre>
  </body>
</html>
